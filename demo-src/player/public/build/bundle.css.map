{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "ImageAsset.svelte",
    "TextAsset.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport {SyncMedia} from './synclib.js';\n\timport {syncMedia, currentTimegraphEntry, playState} from './store.js';\n\timport AudioAsset from './AudioAsset.svelte';\n\timport TextAsset from './TextAsset.svelte';\n\timport ImageAsset from './ImageAsset.svelte';\n\timport VideoAsset from './VideoAsset.svelte';\n\n\tlet mediaWait = 0;\n\tlet mediaDoneCount = 0;\n\n\tcurrentTimegraphEntry.subscribe(() => {\n\t\tif ($currentTimegraphEntry && $currentTimegraphEntry.events) {\n\t\t\tlet playingEvents = $currentTimegraphEntry.events.filter(event => \n\t\t\t\t(event.node.type == \"audio\" || event.node.type == \"video\") && event.last);\n\t\t\tmediaWait = playingEvents.length; \n\t\t\tconsole.log(`waiting for ${mediaWait} nodes to finish`);\n\t\t\tplayingEvents.map(e => console.log(\"... \", e.node.src.href));\n\t\t}\n\t});\n\tfunction mediaDone(event) {\n\t\tconsole.log(\"Media done\", event.detail.event.node.src);\n\t\tif (event.detail.event.last) {\n\t\t\tmediaDoneCount++;\n\t\t}\n\t\tif (mediaDoneCount >= mediaWait) {\n\t\t\tmediaDoneCount = 0;\n\t\t\tif ($syncMedia.canGotoNext()) {\n\t\t\t\tconsole.log(\"proceeding\");\n\t\t\t\tsyncMedia.next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconsole.log(\"DOC DONE\");\n\t\t\t}\t\n\t\t}\n\t\t// else still waiting for more media to finish before proceeding along timegraph\n\t};\n\tfunction pause() {\n\t\tconsole.log(\"click pause\");\n\t\tplayState.set(\"STOPPED\");\n\t}\n\tfunction resume() {\n\t\tconsole.log(\"click play\");\n\t\tplayState.set(\"PLAYING\");\n\t}\n\n\tasync function loadSyncMedia() {\n\t\t// let file = '/fairytale/THE-MASTER-CAT;-OR,-PUSS-IN-BOOTS.xml';\n\t\tlet file = '/cc-shared-culture/cc-shared-culture.xml';\n\t\tlet url = new URL(file, document.baseURI);\n\t\tlet parsedSyncMedia = new SyncMedia();\n\t\tawait parsedSyncMedia.loadUrl(url);\n\t\tsyncMedia.set(parsedSyncMedia);\n\t\treturn syncMedia;\n\t}\n\n\tlet promise = loadSyncMedia();\n\n</script>\n\n\n{#await promise }\n\n<p>Loading...</p>\n\n{:then}\n<!-- for every asset, create a renderer that will respond to updates to data in the store -->\n{#each $syncMedia.assets.filter(a => a.type == \"audio\") as asset}\n<AudioAsset {asset} on:done={mediaDone}/>\n{/each}\n\n<div class=\"texts\">\n\t{#each $syncMedia.assets.filter(a => a.type == \"text\") as asset}\n\t<TextAsset {asset}/>\n\t{/each}\n</div>\n\n<div class=\"images\">\n\t{#each $syncMedia.assets.filter(a => a.type == \"image\") as asset}\n\t<ImageAsset {asset}/>\n\t{/each}\n</div>\n\n<div class=\"videos\">\n\t{#each $syncMedia.assets.filter(a => a.type == \"video\") as asset}\n\t<VideoAsset {asset}/>\n\t{/each}\n</div>\n\n<button on:click={syncMedia.previousPlayable} disabled='{!$syncMedia.canGotoPreviousPlayable()}'>Previous</button>\n<button on:click={syncMedia.nextPlayable} disabled='{!$syncMedia.canGotoNextPlayable()}'>Next</button>\n<button on:click={pause}>Pause</button>\n<button on:click={resume}>Play</button>\n\n{/await}\n\n<style>\n\tbutton {\n\t\tdisplay: inline;\n\t\tmargin-right: 2rem;\n\t}\n\tdiv.texts {\n\t\tdisplay: flex;\n\t}\n</style>",
    "<script>\n    import { onMount } from 'svelte';\n    import { currentTimegraphEntry } from './store.js';\n    export let asset;\n\n    let image;\n    let startEvent;\n    let endEvent;\n\n    async function loadImage(asset) {\n        console.log(\"loading image\", asset.src.href);\n        return new Promise((resolve, reject) => {\n            image.onload = () => {\n                console.log(\"loaded image\", image.src);\n                resolve();     \n            };\n            image.setAttribute('src', asset.src.href);\n        });\n    }\n\n    onMount(async () => {\n        console.log(\"image onmount\", asset);\n        await loadImage(asset);\n        update();\n    });\n\n    currentTimegraphEntry.subscribe(() => {\n        if (image) update();\n    });\n    \n    function update() {\n        console.log(\"Current tg point\", $currentTimegraphEntry);\n        // events relevant to this asset\n        let events = $currentTimegraphEntry.events.filter(event => \n            event.node.type == \"image\" &&\n            event.node.src.href == asset.src);\n        startEvent = events.find(event => event.eventType == \"start\");\n        endEvent = events.find(event => event.eventType == \"end\");\n\n        if (startEvent) {\n            image.classList.remove(\"nodisplay\");\n            applyStyle();\n        }\n        if (endEvent && !startEvent) {\n            image.classList.add(\"nodisplay\");\n        }\n    }\n    \n</script>\n<img class=\"nodisplay\" bind:this={image}>\n\n<style>\n    img.nodisplay {\n        display: none;\n    }\n</style>",
    "<script>\n    import { onMount } from 'svelte';\n    import { currentTimegraphEntry, syncMedia } from './store.js';\n    export let asset;\n\n    let iframe;\n    let startEvents;\n    let endEvents;\n    \n    // keep track of what class(es) the current step has added\n    // the user could press prev/next before we reach an end event for the current start event\n    // so we might have to undo what the start event did manually\n    let startEventCssClasses = [];\n    let directionOfTimegraph = 1; // 1 = forward; -1 = backward\n    let timegraphEntryIndex = 0;\n\n    let isInViewport = (elm, doc=iframe.contentDocument) => {\n        let bounding = elm.getBoundingClientRect();\n        return (\n            bounding.top >= 0 &&\n            bounding.left >= 0 &&\n            bounding.bottom <= (doc.defaultView.innerHeight || doc.documentElement.clientHeight) &&\n            bounding.right <= (doc.defaultView.innerWidth || doc.documentElement.clientWidth)\n        );\n    };\n\n    let applyStyle = (selector, cssClass) => {\n        console.log(\"Apply style\", selector, cssClass);\n        if (iframe.contentDocument) {\n            let elm = iframe.contentDocument.querySelector(selector);\n            // apply css class\n            if (cssClass) {\n                elm.classList.add(cssClass);\n            }\n            // ensure element is visible\n            if (!isInViewport(elm)) {\n                elm.scrollIntoView();\n            }\n        }\n    };\n    let removeStyle = (selector, cssClass) => {\n        console.log(\"Remove style\", selector, cssClass);\n        if (iframe.contentDocument) {\n            let elm = iframe.contentDocument.querySelector(selector);\n            // remove css class\n            if (cssClass) {\n                elm.classList.remove(cssClass);\n            }\n        }\n    }\n\n    async function loadIframe(asset) {\n        console.log(\"loading text\", asset.src.href);\n        return new Promise((resolve, reject) => {\n            //let iframeElement = document.querySelector(\"iframe\");\n            iframe.onload = () => {\n                console.log(\"loaded text\", iframe.src);\n                resolve();     \n            };\n            iframe.setAttribute('src', asset.src.href);\n        });\n    }\n\n    onMount(async () => {\n        console.log(\"text onmount\", asset);\n        await loadIframe(asset);\n        update();\n    });\n\n    currentTimegraphEntry.subscribe(() => {\n        if (iframe) update();\n    });\n    \n    function update() {\n        \n        console.log(\"Current tg point\", $currentTimegraphEntry);\n        // events relevant to this asset\n        let events = $currentTimegraphEntry.events.filter(event => \n            event.node.type == \"text\" &&\n            event.node.src.href == asset.src);\n        startEvents = events.filter(event => event.eventType == \"start\");\n        endEvents = events.filter(event => event.eventType == \"end\");\n\n        if (startEvents) {\n            console.log(\"showing iframe\", iframe.src);\n            iframe.classList.remove(\"nodisplay\");\n            startEvents.map(startEvent => applyStyle(startEvent.node.selector, startEvent.node.params.cssClass));\n        }\n        if (endEvents) {\n            endEvents.map(endEvent => {\n                console.log(\"end event\", endEvent);\n                removeStyle(endEvent.node.selector, endEvent.node.params.cssClass);\n            });\n\n            // if nothing new is starting\n            if (!startEvents) {\n            \n                if ($syncMedia.canGotoNext()) {\n                    console.log(\"hiding iframe\", iframe.src);\n                    iframe.classList.add(\"nodisplay\");\n                }\n                else {\n                    // keep the text around, we're at the end\n                }\n            }\n        } \n    }\n    \n</script>\n<iframe class=\"nodisplay\" bind:this={iframe}></iframe>\n\n<style>\n    iframe {\n        height: 90vh;\n        width: 90vw;\n    }\n    iframe.nodisplay {\n        display: none;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "AAiGC,MAAM,eAAC,CAAC,AACP,OAAO,CAAE,MAAM,CACf,YAAY,CAAE,IAAI,AACnB,CAAC,AACD,GAAG,MAAM,eAAC,CAAC,AACV,OAAO,CAAE,IAAI,AACd,CAAC;ACnDE,GAAG,UAAU,eAAC,CAAC,AACX,OAAO,CAAE,IAAI,AACjB,CAAC;AC0DD,MAAM,cAAC,CAAC,AACJ,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,AACf,CAAC,AACD,MAAM,UAAU,cAAC,CAAC,AACd,OAAO,CAAE,IAAI,AACjB,CAAC"
}